	The front end of Facebook consists of Linux & Apache, PHP, Memcache, Haystack and Big Pipe while the back end is made up of thrift (protocol), Cassandra (database), Scribe (log server) and HipHop. 
	PHP or hypertext preprocessor is a scripting language Facebook uses along with HipHop. HipHop transforms PHP source code into C++ then uses g++ to compile it to machine code. Facebook actually created HipHop to save room on their servers and is an open source project available on GitHub. HipHob transforms code into a native language on it's servers and boosts overall performance. 
	Haystack is used for storing and retrieving pictures on Facebook. With over 20 billion uploaded photos (each of which are then resized to four different resolutions) performance is critical. Facebook serves about 1.2 million photos every second. They have done this by reinventing their photo infrastructure and merging together the photo serving tier along with the photo storing tier. Since Haystack is an object store, it doesn't necessarily have to store photos. They have created an index within Haystack that reads each I/O operation (input/output) into actual photo data. So that when a user inputs a command, Haystack then looks for that one needs it needs to find. Every input contains a direct reference to the storage offset containing the appropriate data, delivering the output at a much quicker speed than their previous photo infrastructure with NFS. 
	BigPipe is a dynamic web page serving system that Facebook developed that successfully runs Facebook at twice the speed it used to. What Facebook did when they created this web page serving system, was break down the web pages into chunks which are called "pagelets". The general idea is that they are pipelining page lets at a quicker rate. It is implemented entirely in PHP and JavaScript.    
	Memcache is implemented to speed up Facebook by alleviating the database load. It is an in-memory key-value store for small amounts of random data, such as strings or objects resulting from calls or page renderings. Set up with a client to server architecture, the server has a key-value array and the client calls for it with its query. It cuts down on database load by discarding the oldest value when the server runs of of RAM. It also allows for clients to read each other's cached data.  

